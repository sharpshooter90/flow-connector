<style>
  body {
    font-family: 'Inter', sans-serif;
    margin: 0;
    background: #f8f9fa;
    height: 100vh;
    overflow: hidden;
  }
  
  .main-container {
    display: flex;
    height: 100vh;
  }
  
  .left-panel {
    width: 280px;
    padding: 16px;
    background: #ffffff;
    border-right: 1px solid #e0e0e0;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  
  .left-panel-content {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 80px; /* Space for sticky buttons */
  }
  
  .right-panel {
    flex: 1;
    padding: 16px;
    background: #f8f9fa;
    display: flex;
    flex-direction: column;
  }
  
  .preview-header {
    margin-bottom: 16px;
  }
  
  .preview-header h3 {
    margin: 0 0 12px 0;
    font-size: 12px;
    font-weight: 600;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .preview-label-input {
    margin-bottom: 16px;
  }
  
  .preview-label-input label {
    display: block;
    margin-bottom: 4px;
    font-size: 10px;
    font-weight: 600;
    color: #333;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .preview-label-input input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 12px;
    box-sizing: border-box;
  }
  
  h2 {
    margin: 0 0 12px 0;
    color: #1a1a1a;
    font-size: 14px;
    font-weight: 600;
  }
  
  .status {
    padding: 6px 10px;
    border-radius: 4px;
    margin-bottom: 12px;
    font-size: 11px;
  }
  
  .preview-container {
    flex: 1;
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    padding: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  
  .preview-canvas {
    width: 240px;
    height: 160px;
    position: relative;
  }
  
  .frame-preview {
    position: absolute;
    width: 50px;
    height: 35px;
    background: #1976d2;
    border-radius: 6px;
    border: 2px solid #1565c0;
  }
  
  .frame-1 {
    top: 30px;
    left: 30px;
  }
  
  .frame-2 {
    top: 95px;
    right: 30px;
  }
  
  .connection-preview {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
  }
  
  .connection-preview svg {
    width: 240px;
    height: 160px;
  }
  
  .status.info {
    background: #e3f2fd;
    color: #1976d2;
    border: 1px solid #bbdefb;
  }
  
  .status.success {
    background: #e8f5e8;
    color: #2e7d32;
    border: 1px solid #c8e6c9;
  }
  
  .status.error {
    background: #ffebee;
    color: #c62828;
    border: 1px solid #ffcdd2;
  }
  
  .status.editing {
    background: #fff3e0;
    color: #f57c00;
    border: 1px solid #ffcc02;
  }
  
  .form-group {
    margin-bottom: 10px;
  }
  
  label {
    display: block;
    margin-bottom: 4px;
    font-size: 10px;
    font-weight: 600;
    color: #333;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .color-grid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
    margin-bottom: 4px;
  }
  
  .color-option {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .color-option.selected {
    border-color: #0066cc;
    transform: scale(1.1);
  }
  
  .option-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    margin-bottom: 4px;
  }
  
  .option-button {
    padding: 6px 3px;
    border: 2px solid #e0e0e0;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    text-align: center;
    font-size: 9px;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 28px;
    position: relative;
  }
  
  .option-button.selected {
    border-color: #7c4dff;
    background: #7c4dff;
    color: white;
  }
  
  .option-button:hover {
    border-color: #7c4dff;
  }
  
  input[type="range"] {
    width: 100%;
    margin: 8px 0;
  }
  
  .range-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #666;
    margin-top: 4px;
  }
  
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-bottom: 8px;
  }
  
  .checkbox-container label {
    font-size: 10px;
    text-transform: none;
    letter-spacing: normal;
  }
  
  input[type="checkbox"] {
    width: auto;
  }
  
.button-group {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    gap: 6px;
    background: white;
    border-top: 1px solid #e0e0e0;
    padding: 16px;
    z-index: 9;
}
  
  button {
    flex: 1;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  
  .primary {
    background: #0066cc;
    color: white;
  }
  
  .primary:hover {
    background: #0052a3;
  }
  
  .primary:disabled {
    background: #ccc;
    cursor: not-allowed;
  }
  
  .secondary {
    background: #f0f0f0;
    color: #333;
  }
  
  .secondary:hover {
    background: #e0e0e0;
  }
  
  input[type="text"] {
    width: 100%;
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-size: 10px;
    box-sizing: border-box;
  }
  
  /* Custom stroke width indicators */
  .stroke-width-1::after { content: ''; position: absolute; width: 16px; height: 1px; background: #333; }
  .stroke-width-2::after { content: ''; position: absolute; width: 16px; height: 2px; background: #333; }
  .stroke-width-3::after { content: ''; position: absolute; width: 16px; height: 3px; background: #333; }
  .stroke-width-4::after { content: ''; position: absolute; width: 16px; height: 4px; background: #333; }
  
  /* Custom stroke style indicators */
  .stroke-solid::after { content: ''; position: absolute; width: 16px; height: 2px; background: #333; }
  .stroke-dashed::after { 
    content: ''; 
    position: absolute; 
    width: 16px; 
    height: 2px; 
    background: linear-gradient(to right, #333 40%, transparent 40%, transparent 60%, #333 60%);
    background-size: 4px 2px;
  }
  .stroke-dotted::after { 
    content: ''; 
    position: absolute; 
    width: 16px; 
    height: 2px; 
    background: linear-gradient(to right, #333 25%, transparent 25%, transparent 75%, #333 75%);
    background-size: 3px 2px;
  }
  
  /* Custom sloppiness indicators */
  .sloppiness-none svg { filter: none; }
  .sloppiness-low svg { filter: url(#roughen-low); }
  .sloppiness-high svg { filter: url(#roughen-high); }
  
  /* SVG icons */
  .option-button svg {
    width: 18px;
    height: 10px;
    stroke: #333;
    fill: none;
    stroke-width: 1.5;
  }
  
  .option-button.selected svg {
    stroke: white;
  }
  
  /* Tab styles */
  .tabs {
    display: flex;
    margin-bottom: 12px;
    border-bottom: 1px solid #e0e0e0;
  }
  
  .tab {
    flex: 1;
    padding: 8px 12px;
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #666;
    transition: all 0.2s;
  }
  
  .tab.active {
    color: #0066cc;
    border-bottom-color: #0066cc;
  }
  
  .tab-content {
    display: none;
  }
  
  .tab-content.active {
    display: block;
  }
</style>

<div class="main-container">
  <div class="left-panel">
    <div class="left-panel-content">
      <h2>Flow Connector</h2>
      
      <div id="status" class="status info">
        Select 2 frames with Shift+Click to create a connection
      </div>
      
      <div class="checkbox-container">
        <input type="checkbox" id="autoCreate" checked>
        <label for="autoCreate" style="margin: 0; font-weight: normal;">Auto-create on selection</label>
      </div>
      
      <div class="checkbox-container">
        <input type="checkbox" id="autoUpdate" checked>
        <label for="autoUpdate" style="margin: 0; font-weight: normal;">Auto-update when frames move</label>
      </div>
      
      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" data-tab="arrow">Arrow</button>
        <button class="tab" data-tab="label">Label</button>
      </div>
  
  <!-- SVG Filters for sloppiness effect -->
  <svg width="0" height="0" style="position: absolute;">
    <defs>
      <filter id="roughen-low">
        <feTurbulence baseFrequency="0.04" numOctaves="3" result="noise"/>
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="0.5"/>
      </filter>
      <filter id="roughen-high">
        <feTurbulence baseFrequency="0.08" numOctaves="4" result="noise"/>
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.2"/>
      </filter>
    </defs>
  </svg>

      <!-- Arrow Tab Content -->
      <div class="tab-content active" id="arrow-tab">
        <div class="form-group">
          <label>Stroke</label>
          <div class="color-grid">
            <div class="color-option selected" data-color="#2c2c2c" style="background: #2c2c2c;"></div>
            <div class="color-option" data-color="#dc3545" style="background: #dc3545;"></div>
            <div class="color-option" data-color="#28a745" style="background: #28a745;"></div>
            <div class="color-option" data-color="#1976d2" style="background: #1976d2;"></div>
            <div class="color-option" data-color="#ff9800" style="background: #ff9800;"></div>
            <div class="color-option" data-color="#2196f3" style="background: #2196f3;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Stroke width</label>
          <div class="option-grid">
            <div class="option-button stroke-width-1" data-width="1"></div>
            <div class="option-button stroke-width-2" data-width="2"></div>
            <div class="option-button selected stroke-width-3" data-width="3"></div>
            <div class="option-button stroke-width-4" data-width="4"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Stroke style</label>
          <div class="option-grid">
            <div class="option-button selected stroke-solid" data-style="solid"></div>
            <div class="option-button stroke-dashed" data-style="dashed"></div>
            <div class="option-button stroke-dotted" data-style="dotted"></div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Sloppiness</label>
          <div class="option-grid">
            <div class="option-button sloppiness-none" data-sloppiness="none">
              <svg><line x1="2" y1="6" x2="18" y2="6"/></svg>
            </div>
            <div class="option-button selected sloppiness-low" data-sloppiness="low">
              <svg><line x1="2" y1="6" x2="18" y2="6" class="low-rough"/></svg>
            </div>
            <div class="option-button sloppiness-high" data-sloppiness="high">
              <svg><path d="M2,6 Q6,4 10,6 T18,6" class="high-rough"/></svg>
            </div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Arrow type</label>
          <div class="option-grid">
            <div class="option-button" data-arrow-type="straight">
              <svg><line x1="2" y1="5" x2="16" y2="5"/><polygon points="13,2 16,5 13,8" fill="currentColor"/></svg>
            </div>
            <div class="option-button" data-arrow-type="curved">
              <svg><path d="M2,5 Q9,1 16,5"/><polygon points="13,2 16,5 13,8" fill="currentColor"/></svg>
            </div>
            <div class="option-button selected" data-arrow-type="elbow">
              <svg><path d="M2,5 L9,5 L9,2 L16,2"/><polygon points="13,0 16,2 13,4" fill="currentColor"/></svg>
            </div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Arrowheads</label>
          <div class="option-grid">
            <div class="option-button" data-arrowheads="none">
              <svg><line x1="2" y1="5" x2="16" y2="5"/></svg>
            </div>
            <div class="option-button selected" data-arrowheads="end">
              <svg><line x1="2" y1="5" x2="16" y2="5"/><polygon points="13,2 16,5 13,8" fill="currentColor"/></svg>
            </div>
            <div class="option-button" data-arrowheads="both">
              <svg><line x1="2" y1="5" x2="16" y2="5"/><polygon points="5,2 2,5 5,8" fill="currentColor"/><polygon points="13,2 16,5 13,8" fill="currentColor"/></svg>
            </div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Start Position</label>
          <div class="option-grid">
            <div class="option-button selected" data-start-position="auto">Auto</div>
            <div class="option-button" data-start-position="top">Top</div>
            <div class="option-button" data-start-position="right">Right</div>
            <div class="option-button" data-start-position="bottom">Bottom</div>
            <div class="option-button" data-start-position="left">Left</div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>End Position</label>
          <div class="option-grid">
            <div class="option-button selected" data-end-position="auto">Auto</div>
            <div class="option-button" data-end-position="top">Top</div>
            <div class="option-button" data-end-position="right">Right</div>
            <div class="option-button" data-end-position="bottom">Bottom</div>
            <div class="option-button" data-end-position="left">Left</div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Connection Offset</label>
          <input type="range" id="connectionOffset" min="0" max="50" value="20">
          <div class="range-container">
            <span>0</span>
            <span id="connectionOffsetValue">20</span>
            <span>50</span>
          </div>
        </div>
        
        <div class="checkbox-container">
          <input type="checkbox" id="avoidOverlap" checked>
          <label for="avoidOverlap" style="margin: 0; font-weight: normal;">Avoid frame overlap</label>
        </div>
        
        <div class="form-group">
          <label>Opacity</label>
          <input type="range" id="opacity" min="0" max="100" value="100">
          <div class="range-container">
            <span>0</span>
            <span id="opacityValue">100</span>
            <span>100</span>
          </div>
        </div>
      </div>
      
      <!-- Label Tab Content -->
      <div class="tab-content" id="label-tab">
        
        <div class="form-group">
          <label>Text Color</label>
          <div class="color-grid">
            <div class="color-option selected" data-label-text-color="#333333" style="background: #333333;"></div>
            <div class="color-option" data-label-text-color="#ffffff" style="background: #ffffff; border: 1px solid #ddd;"></div>
            <div class="color-option" data-label-text-color="#dc3545" style="background: #dc3545;"></div>
            <div class="color-option" data-label-text-color="#28a745" style="background: #28a745;"></div>
            <div class="color-option" data-label-text-color="#1976d2" style="background: #1976d2;"></div>
            <div class="color-option" data-label-text-color="#ff9800" style="background: #ff9800;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Background Color</label>
          <div class="color-grid">
            <div class="color-option selected" data-label-bg="#ffffff" style="background: #ffffff; border: 1px solid #ddd;"></div>
            <div class="color-option" data-label-bg="#f8f9fa" style="background: #f8f9fa;"></div>
            <div class="color-option" data-label-bg="#333333" style="background: #333333;"></div>
            <div class="color-option" data-label-bg="#1976d2" style="background: #1976d2;"></div>
            <div class="color-option" data-label-bg="#28a745" style="background: #28a745;"></div>
            <div class="color-option" data-label-bg="#ff9800" style="background: #ff9800;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Border Color</label>
          <div class="color-grid">
            <div class="color-option selected" data-label-border="#e0e0e0" style="background: #e0e0e0;"></div>
            <div class="color-option" data-label-border="#333333" style="background: #333333;"></div>
            <div class="color-option" data-label-border="#dc3545" style="background: #dc3545;"></div>
            <div class="color-option" data-label-border="#28a745" style="background: #28a745;"></div>
            <div class="color-option" data-label-border="#1976d2" style="background: #1976d2;"></div>
            <div class="color-option" data-label-border="#ff9800" style="background: #ff9800;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Border Width</label>
          <div class="option-grid">
            <div class="option-button" data-label-border-width="0">0</div>
            <div class="option-button selected" data-label-border-width="1">1</div>
            <div class="option-button" data-label-border-width="2">2</div>
            <div class="option-button" data-label-border-width="3">3</div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Label Position</label>
          <div class="option-grid">
            <div class="option-button selected" data-label-position="center">Center</div>
            <div class="option-button" data-label-position="top">Top</div>
            <div class="option-button" data-label-position="bottom">Bottom</div>
            <div class="option-button" style="visibility: hidden;"></div>
          </div>
        </div>
        
        <div class="form-group">
          <label>Label Offset</label>
          <input type="range" id="labelOffset" min="0" max="30" value="10">
          <div class="range-container">
            <span>0</span>
            <span id="labelOffsetValue">10</span>
            <span>30</span>
          </div>
        </div>
        
        <div class="form-group">
          <label>Border Radius</label>
          <input type="range" id="labelBorderRadius" min="0" max="12" value="4">
          <div class="range-container">
            <span>0</span>
            <span id="labelBorderRadiusValue">4</span>
            <span>12</span>
          </div>
        </div>
        
        <div class="form-group">
          <label>Padding</label>
          <input type="range" id="labelPadding" min="2" max="12" value="6">
          <div class="range-container">
            <span>2</span>
            <span id="labelPaddingValue">6</span>
            <span>12</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="button-group">
      <button id="create" class="primary" disabled>Create Connection</button>
      <button id="cancel" class="secondary">Cancel</button>
    </div>
  </div>
  
  <div class="right-panel">
    <div class="preview-header">
      <h3>Preview</h3>
      <div class="preview-label-input">
        <label for="labelPreview">Label Text</label>
        <input type="text" id="labelPreview" placeholder="Label Text" value="Label Text">
      </div>
    </div>
    <div class="preview-container">
      <div class="preview-canvas">
        <div class="frame-preview frame-1"></div>
        <div class="frame-preview frame-2"></div>
        <div class="connection-preview">
          <svg id="previewSvg">
            <defs>
              <filter id="preview-roughen-low">
                <feTurbulence baseFrequency="0.04" numOctaves="3" result="noise"/>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="0.3"/>
              </filter>
              <filter id="preview-roughen-high">
                <feTurbulence baseFrequency="0.08" numOctaves="4" result="noise"/>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="0.8"/>
              </filter>
            </defs>
            <g id="previewConnection">
              <!-- Connection will be drawn here -->
            </g>
          </svg>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  let frameCount = 0;
  let connectionCount = 0;
  
  // Shared debouncer for label configuration changes
  let labelConfigDebounceTimer = null;
  
  function debounceLabelUpdate() {
    // Clear existing timer
    if (labelConfigDebounceTimer) {
      clearTimeout(labelConfigDebounceTimer);
    }
    
    // Update preview immediately for responsive UI
    updatePreview();
    
    // Debounce the actual connection update and save
    labelConfigDebounceTimer = setTimeout(() => {
      saveConfig();
      if (isEditingConnection) {
        updateConnection();
      } else {
        checkAutoCreate();
      }
    }, 300); // 300ms delay
  }
  let selectedConnectionId = null;
  let isEditingConnection = false;
  
  // Default config (will be overridden by saved config from backend)
  let config = {
    color: '#2c2c2c',
    strokeWidth: 3,
    strokeStyle: 'solid',
    sloppiness: 'low',
    arrowType: 'elbow',
    arrowheads: 'end',
    startPosition: 'auto',
    endPosition: 'auto',
    connectionOffset: 20,
    avoidOverlap: true,
    opacity: 100,
    label: 'Label Text',
    labelPosition: 'center',
    labelOffset: 10,
    labelBg: '#ffffff',
    labelTextColor: '#333333',
    labelBorderColor: '#e0e0e0',
    labelBorderWidth: 1,
    labelBorderRadius: 4,
    labelPadding: 6
  };
  
  // Figma storage functions
  function saveConfig() {
    try {
      // Send config to backend for storage
      parent.postMessage({ 
        pluginMessage: { 
          type: 'save-config', 
          config: config 
        } 
      }, '*');
    } catch (error) {
      console.warn('Failed to save config:', error);
    }
  }
  
  function loadConfig() {
    // Config will be loaded by backend and sent to UI on initialization
    return null; // Backend will send the config via message
  }
  
  // Helper function to check if a line intersects with a rectangle (frame) - Preview version
  function previewLineIntersectsRect(lineStart, lineEnd, rect) {
    const padding = 5; // Smaller padding for preview
    const expandedRect = {
      x: rect.x - padding,
      y: rect.y - padding,
      width: rect.width + (padding * 2),
      height: rect.height + (padding * 2)
    };

    const rectLeft = expandedRect.x;
    const rectRight = expandedRect.x + expandedRect.width;
    const rectTop = expandedRect.y;
    const rectBottom = expandedRect.y + expandedRect.height;

    if ((lineStart.x < rectLeft && lineEnd.x < rectLeft) ||
        (lineStart.x > rectRight && lineEnd.x > rectRight) ||
        (lineStart.y < rectTop && lineEnd.y < rectTop) ||
        (lineStart.y > rectBottom && lineEnd.y > rectBottom)) {
      return false;
    }

    const lineLeft = Math.min(lineStart.x, lineEnd.x);
    const lineRight = Math.max(lineStart.x, lineEnd.x);
    const lineTop = Math.min(lineStart.y, lineEnd.y);
    const lineBottom = Math.max(lineStart.y, lineEnd.y);

    return !(lineRight < rectLeft || lineLeft > rectRight || lineBottom < rectTop || lineTop > rectBottom);
  }

  // Helper function to determine the best routing path to avoid overlaps - Preview version
  function calculatePreviewAvoidanceRoute(frame1, frame2, startPoint, endPoint, config) {
    if (!config.avoidOverlap) {
      return { startPoint, endPoint, waypoints: [] };
    }

    const directPathIntersectsFrame1 = previewLineIntersectsRect(startPoint, endPoint, frame1);
    const directPathIntersectsFrame2 = previewLineIntersectsRect(startPoint, endPoint, frame2);

    if (!directPathIntersectsFrame1 && !directPathIntersectsFrame2) {
      return { startPoint, endPoint, waypoints: [] };
    }

    const dx = Math.abs(endPoint.x - startPoint.x);
    const dy = Math.abs(endPoint.y - startPoint.y);
    const isHorizontalPrimary = dx > dy;

    let waypoints = [];

    if (isHorizontalPrimary) {
      const frame1Bottom = frame1.y + frame1.height;
      const frame1Top = frame1.y;
      const frame2Bottom = frame2.y + frame2.height;
      const frame2Top = frame2.y;

      const maxBottom = Math.max(frame1Bottom, frame2Bottom);
      const minTop = Math.min(frame1Top, frame2Top);
      
      const clearance = config.connectionOffset + 10;
      const routeAboveY = minTop - clearance;
      const routeBelowY = maxBottom + clearance;
      
      const avgY = (startPoint.y + endPoint.y) / 2;
      const useAbove = Math.abs(routeAboveY - avgY) < Math.abs(routeBelowY - avgY);
      
      const routeY = useAbove ? routeAboveY : routeBelowY;
      
      waypoints = [
        { x: startPoint.x, y: routeY },
        { x: endPoint.x, y: routeY }
      ];
    } else {
      const frame1Right = frame1.x + frame1.width;
      const frame1Left = frame1.x;
      const frame2Right = frame2.x + frame2.width;
      const frame2Left = frame2.x;

      const maxRight = Math.max(frame1Right, frame2Right);
      const minLeft = Math.min(frame1Left, frame2Left);
      
      const clearance = config.connectionOffset + 10;
      const routeLeftX = minLeft - clearance;
      const routeRightX = maxRight + clearance;
      
      const avgX = (startPoint.x + endPoint.x) / 2;
      const useLeft = Math.abs(routeLeftX - avgX) < Math.abs(routeRightX - avgX);
      
      const routeX = useLeft ? routeLeftX : routeRightX;
      
      waypoints = [
        { x: routeX, y: startPoint.y },
        { x: routeX, y: endPoint.y }
      ];
    }

    return { startPoint, endPoint, waypoints };
  }

  // Calculate connection points for preview (similar to backend logic)
  function calculatePreviewConnectionPoints(frame1, frame2, config) {
    const frame1Center = {
      x: frame1.x + frame1.width / 2,
      y: frame1.y + frame1.height / 2
    };

    const frame2Center = {
      x: frame2.x + frame2.width / 2,
      y: frame2.y + frame2.height / 2
    };

    let startPoint, endPoint, startOffsetPoint, endOffsetPoint;

    // Calculate start point based on config or auto-detect
    if (config.startPosition === 'auto') {
      // Auto-detect based on relative positions
      const dx = frame2Center.x - frame1Center.x;
      const dy = frame2Center.y - frame1Center.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal connection
        if (dx > 0) {
          startPoint = { x: frame1.x + frame1.width, y: frame1Center.y }; // right
          startOffsetPoint = { x: startPoint.x + config.connectionOffset, y: startPoint.y };
        } else {
          startPoint = { x: frame1.x, y: frame1Center.y }; // left
          startOffsetPoint = { x: startPoint.x - config.connectionOffset, y: startPoint.y };
        }
      } else {
        // Vertical connection
        if (dy > 0) {
          startPoint = { x: frame1Center.x, y: frame1.y + frame1.height }; // bottom
          startOffsetPoint = { x: startPoint.x, y: startPoint.y + config.connectionOffset };
        } else {
          startPoint = { x: frame1Center.x, y: frame1.y }; // top
          startOffsetPoint = { x: startPoint.x, y: startPoint.y - config.connectionOffset };
        }
      }
    } else {
      // Use specified position
      switch (config.startPosition) {
        case 'top':
          startPoint = { x: frame1Center.x, y: frame1.y };
          startOffsetPoint = { x: startPoint.x, y: startPoint.y - config.connectionOffset };
          break;
        case 'right':
          startPoint = { x: frame1.x + frame1.width, y: frame1Center.y };
          startOffsetPoint = { x: startPoint.x + config.connectionOffset, y: startPoint.y };
          break;
        case 'bottom':
          startPoint = { x: frame1Center.x, y: frame1.y + frame1.height };
          startOffsetPoint = { x: startPoint.x, y: startPoint.y + config.connectionOffset };
          break;
        case 'left':
          startPoint = { x: frame1.x, y: frame1Center.y };
          startOffsetPoint = { x: startPoint.x - config.connectionOffset, y: startPoint.y };
          break;
      }
    }

    // Calculate end point based on config or auto-detect
    if (config.endPosition === 'auto') {
      // Auto-detect based on relative positions
      const dx = frame2Center.x - frame1Center.x;
      const dy = frame2Center.y - frame1Center.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal connection
        if (dx > 0) {
          endPoint = { x: frame2.x, y: frame2Center.y }; // left
          endOffsetPoint = { x: endPoint.x - config.connectionOffset, y: endPoint.y };
        } else {
          endPoint = { x: frame2.x + frame2.width, y: frame2Center.y }; // right
          endOffsetPoint = { x: endPoint.x + config.connectionOffset, y: endPoint.y };
        }
      } else {
        // Vertical connection
        if (dy > 0) {
          endPoint = { x: frame2Center.x, y: frame2.y }; // top
          endOffsetPoint = { x: endPoint.x, y: endPoint.y - config.connectionOffset };
        } else {
          endPoint = { x: frame2Center.x, y: frame2.y + frame2.height }; // bottom
          endOffsetPoint = { x: endPoint.x, y: endPoint.y + config.connectionOffset };
        }
      }
    } else {
      // Use specified position
      switch (config.endPosition) {
        case 'top':
          endPoint = { x: frame2Center.x, y: frame2.y };
          endOffsetPoint = { x: endPoint.x, y: endPoint.y - config.connectionOffset };
          break;
        case 'right':
          endPoint = { x: frame2.x + frame2.width, y: frame2Center.y };
          endOffsetPoint = { x: endPoint.x + config.connectionOffset, y: endPoint.y };
          break;
        case 'bottom':
          endPoint = { x: frame2Center.x, y: frame2.y + frame2.height };
          endOffsetPoint = { x: endPoint.x, y: endPoint.y + config.connectionOffset };
          break;
        case 'left':
          endPoint = { x: frame2.x, y: frame2Center.y };
          endOffsetPoint = { x: endPoint.x - config.connectionOffset, y: endPoint.y };
          break;
      }
    }

    // Calculate avoidance routing if enabled
    const avoidanceRoute = calculatePreviewAvoidanceRoute(frame1, frame2, startOffsetPoint, endOffsetPoint, config);

    return { 
      startPoint, 
      endPoint, 
      startOffsetPoint, 
      endOffsetPoint,
      waypoints: avoidanceRoute.waypoints
    };
  }

  // Helper function to calculate the label position based on path and configuration - Preview version
  function calculatePreviewLabelPosition(startPoint, endPoint, startOffsetPoint, endOffsetPoint, waypoints, config) {
    // Validate input points and provide fallbacks
    const safeStartPoint = { 
      x: isNaN(startPoint?.x) ? 0 : startPoint.x, 
      y: isNaN(startPoint?.y) ? 0 : startPoint.y 
    };
    const safeEndPoint = { 
      x: isNaN(endPoint?.x) ? 100 : endPoint.x, 
      y: isNaN(endPoint?.y) ? 100 : endPoint.y 
    };
    const safeStartOffsetPoint = { 
      x: isNaN(startOffsetPoint?.x) ? safeStartPoint.x : startOffsetPoint.x, 
      y: isNaN(startOffsetPoint?.y) ? safeStartPoint.y : startOffsetPoint.y 
    };
    const safeEndOffsetPoint = { 
      x: isNaN(endOffsetPoint?.x) ? safeEndPoint.x : endOffsetPoint.x, 
      y: isNaN(endOffsetPoint?.y) ? safeEndPoint.y : endOffsetPoint.y 
    };

    // Build the actual path points in order
    const pathPoints = [safeStartPoint];
    
    // Add offset point if we have one
    if (config.connectionOffset > 0) {
      pathPoints.push(safeStartOffsetPoint);
    }
    
    // Add all waypoints (with validation)
    if (waypoints && waypoints.length > 0) {
      for (const waypoint of waypoints) {
        if (!isNaN(waypoint?.x) && !isNaN(waypoint?.y)) {
          pathPoints.push(waypoint);
        }
      }
    }
    
    // Add end offset point if we have one
    if (config.connectionOffset > 0) {
      pathPoints.push(safeEndOffsetPoint);
    }
    
    // Add end point
    pathPoints.push(safeEndPoint);
    
    // Calculate the total path length and find the center point
    let totalLength = 0;
    const segments = [];
    
    for (let i = 0; i < pathPoints.length - 1; i++) {
      const start = pathPoints[i];
      const end = pathPoints[i + 1];
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      
      // Skip zero-length segments
      if (length > 0) {
        segments.push({ start, end, length });
        totalLength += length;
      }
    }
    
    // Fallback to simple midpoint if no valid segments
    if (segments.length === 0 || totalLength === 0) {
      const fallbackCenter = {
        x: (safeStartPoint.x + safeEndPoint.x) / 2,
        y: (safeStartPoint.y + safeEndPoint.y) / 2
      };
      
      // Apply simple offset for non-center positions
      if (config.labelPosition === 'top') {
        return { x: fallbackCenter.x, y: fallbackCenter.y - (config.labelOffset || 10) };
      } else if (config.labelPosition === 'bottom') {
        return { x: fallbackCenter.x, y: fallbackCenter.y + (config.labelOffset || 10) };
      }
      
      return fallbackCenter;
    }
    
    // Find the point at half the total length (path center)
    const halfLength = totalLength / 2;
    let currentLength = 0;
    let pathCenter = { x: 0, y: 0 };
    let pathAngle = 0;
    
    for (const segment of segments) {
      if (currentLength + segment.length >= halfLength) {
        // The midpoint is within this segment
        const remainingLength = halfLength - currentLength;
        const ratio = segment.length > 0 ? remainingLength / segment.length : 0;
        
        pathCenter = {
          x: segment.start.x + (segment.end.x - segment.start.x) * ratio,
          y: segment.start.y + (segment.end.y - segment.start.y) * ratio
        };
        
        // Calculate the angle of this segment for offset positioning
        pathAngle = Math.atan2(segment.end.y - segment.start.y, segment.end.x - segment.start.x);
        break;
      }
      currentLength += segment.length;
    }
    
    // Validate pathCenter and provide fallback
    if (isNaN(pathCenter.x) || isNaN(pathCenter.y)) {
      pathCenter = {
        x: (safeStartPoint.x + safeEndPoint.x) / 2,
        y: (safeStartPoint.y + safeEndPoint.y) / 2
      };
      pathAngle = Math.atan2(safeEndPoint.y - safeStartPoint.y, safeEndPoint.x - safeStartPoint.x);
    }
    
    // Apply position offset based on label position setting
    console.log('Preview label position logic:', config.labelPosition, pathCenter, pathAngle); // Debug log
    if (config.labelPosition === 'center') {
      return pathCenter;
    }
    
    // For top/bottom positioning, move along the path towards start/end
    const offsetDistance = config.labelOffset || 10;
    let finalPosition = pathCenter;
    
    if (config.labelPosition === 'top') {
      // "Top" means closer to the start of the arrow (tail end)
      // Move backwards along the path from center
      finalPosition = {
        x: pathCenter.x - Math.cos(pathAngle) * offsetDistance,
        y: pathCenter.y - Math.sin(pathAngle) * offsetDistance
      };
      console.log('Top position calculated (towards start):', finalPosition); // Debug log
    } else if (config.labelPosition === 'bottom') {
      // "Bottom" means closer to the end of the arrow (head end)  
      // Move forwards along the path from center
      finalPosition = {
        x: pathCenter.x + Math.cos(pathAngle) * offsetDistance,
        y: pathCenter.y + Math.sin(pathAngle) * offsetDistance
      };
      console.log('Bottom position calculated (towards end):', finalPosition); // Debug log
    }
    
    // Final validation
    return {
      x: isNaN(finalPosition.x) ? pathCenter.x : finalPosition.x,
      y: isNaN(finalPosition.y) ? pathCenter.y : finalPosition.y
    };
  }

  // Preview update function
  function updatePreview() {
    const svg = document.getElementById('previewSvg');
    const connection = document.getElementById('previewConnection');
    
    // Clear previous connection
    connection.innerHTML = '';
    
    // Frame positions (relative to preview canvas)
    const frame1 = { x: 30, y: 30, width: 50, height: 35 };
    const frame2 = { x: 160, y: 95, width: 50, height: 35 };
    
    // Calculate connection points based on positioning config
    const { startPoint, endPoint, startOffsetPoint, endOffsetPoint, waypoints } = calculatePreviewConnectionPoints(frame1, frame2, config);
    
    // Create path based on arrow type
    let pathData = '';
    
    // If we have waypoints (avoidance routing), create a path through them
    if (waypoints.length > 0) {
      pathData = `M ${startPoint.x} ${startPoint.y}`;
      
      // Add offset point if we have one
      if (config.connectionOffset > 0) {
        pathData += ` L ${startOffsetPoint.x} ${startOffsetPoint.y}`;
      }
      
      // Add all waypoints
      for (const waypoint of waypoints) {
        pathData += ` L ${waypoint.x} ${waypoint.y}`;
      }
      
      // Add end offset point if we have one
      if (config.connectionOffset > 0) {
        pathData += ` L ${endOffsetPoint.x} ${endOffsetPoint.y}`;
      }
      
      // End at the final point
      pathData += ` L ${endPoint.x} ${endPoint.y}`;
    } else {
      // Original logic for direct connections without waypoints
      if (config.arrowType === 'straight') {
        // For straight connections with offset, create an elbow path
        if (config.connectionOffset > 0) {
          pathData = `M ${startPoint.x} ${startPoint.y} L ${startOffsetPoint.x} ${startOffsetPoint.y} L ${endOffsetPoint.x} ${endOffsetPoint.y} L ${endPoint.x} ${endPoint.y}`;
        } else {
          pathData = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
        }
      } else if (config.arrowType === 'elbow') {
        // Create elbow path with offset points
        if (config.connectionOffset > 0) {
          const midX = (startOffsetPoint.x + endOffsetPoint.x) / 2;
          const midY = (startOffsetPoint.y + endOffsetPoint.y) / 2;
          pathData = `M ${startPoint.x} ${startPoint.y} L ${startOffsetPoint.x} ${startOffsetPoint.y} L ${midX} ${startOffsetPoint.y} L ${midX} ${endOffsetPoint.y} L ${endOffsetPoint.x} ${endOffsetPoint.y} L ${endPoint.x} ${endPoint.y}`;
        } else {
          const midX = (startPoint.x + endPoint.x) / 2;
          pathData = `M ${startPoint.x} ${startPoint.y} L ${midX} ${startPoint.y} L ${midX} ${endPoint.y} L ${endPoint.x} ${endPoint.y}`;
        }
      } else { // curved
        // Curved path with offset
        if (config.connectionOffset > 0) {
          const dx = endOffsetPoint.x - startOffsetPoint.x;
          const dy = endOffsetPoint.y - startOffsetPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const curvature = distance * 0.3;

          const controlPoint1 = {
            x: startOffsetPoint.x + (Math.abs(dx) > Math.abs(dy) ? curvature : 0),
            y: startOffsetPoint.y + (Math.abs(dy) > Math.abs(dx) ? curvature * Math.sign(dy) : 0)
          };

          const controlPoint2 = {
            x: endOffsetPoint.x - (Math.abs(dx) > Math.abs(dy) ? curvature : 0),
            y: endOffsetPoint.y - (Math.abs(dy) > Math.abs(dx) ? curvature * Math.sign(dy) : 0)
          };

          pathData = `M ${startPoint.x} ${startPoint.y} L ${startOffsetPoint.x} ${startOffsetPoint.y} C ${controlPoint1.x} ${controlPoint1.y} ${controlPoint2.x} ${controlPoint2.y} ${endOffsetPoint.x} ${endOffsetPoint.y} L ${endPoint.x} ${endPoint.y}`;
        } else {
          // Original curved path without offset
          const dx = endPoint.x - startPoint.x;
          const dy = endPoint.y - startPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const curvature = distance * 0.3;
          
          const controlPoint1 = {
            x: startPoint.x + (Math.abs(dx) > Math.abs(dy) ? curvature : 0),
            y: startPoint.y + (Math.abs(dy) > Math.abs(dx) ? curvature * Math.sign(dy) : 0)
          };
          
          const controlPoint2 = {
            x: endPoint.x - (Math.abs(dx) > Math.abs(dy) ? curvature : 0),
            y: endPoint.y - (Math.abs(dy) > Math.abs(dx) ? curvature * Math.sign(dy) : 0)
          };
          
          pathData = `M ${startPoint.x} ${startPoint.y} C ${controlPoint1.x} ${controlPoint1.y} ${controlPoint2.x} ${controlPoint2.y} ${endPoint.x} ${endPoint.y}`;
        }
      }
    }
    
    // Create main line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    line.setAttribute('d', pathData);
    line.setAttribute('stroke', config.color);
    line.setAttribute('stroke-width', config.strokeWidth);
    line.setAttribute('fill', 'none');
    line.setAttribute('opacity', config.opacity / 100);
    
    // Apply stroke style
    if (config.strokeStyle === 'dashed') {
      line.setAttribute('stroke-dasharray', '5,5');
    } else if (config.strokeStyle === 'dotted') {
      line.setAttribute('stroke-dasharray', '2,3');
    }
    
    // Apply sloppiness filter
    if (config.sloppiness === 'low') {
      line.setAttribute('filter', 'url(#preview-roughen-low)');
    } else if (config.sloppiness === 'high') {
      line.setAttribute('filter', 'url(#preview-roughen-high)');
    }
    
    connection.appendChild(line);
    
    // Add arrowheads
    if (config.arrowheads === 'end' || config.arrowheads === 'both') {
      const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
      const arrowHead = createPreviewArrowHead(endPoint.x, endPoint.y, angle);
      connection.appendChild(arrowHead);
    }
    
    if (config.arrowheads === 'both') {
      const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x) + Math.PI;
      const arrowHead = createPreviewArrowHead(startPoint.x, startPoint.y, angle);
      connection.appendChild(arrowHead);
    }
    
    // Add label if present
    if (config.label.trim()) {
      // Calculate the label position based on configuration
      console.log('Label config:', config.labelPosition, config.labelOffset); // Debug log
      const labelPosition = calculatePreviewLabelPosition(startPoint, endPoint, startOffsetPoint, endOffsetPoint, waypoints, config);
      console.log('Label position result:', labelPosition); // Debug log
      const midX = labelPosition.x;
      const midY = labelPosition.y;
      
      // Create background rectangle
      const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      const textWidth = config.label.length * 6; // Approximate text width
      const textHeight = 12;
      const bgWidth = textWidth + (config.labelPadding * 2);
      const bgHeight = textHeight + (config.labelPadding * 2);
      
      labelBg.setAttribute('x', midX - bgWidth / 2);
      labelBg.setAttribute('y', midY - bgHeight / 2);
      labelBg.setAttribute('width', bgWidth);
      labelBg.setAttribute('height', bgHeight);
      labelBg.setAttribute('fill', config.labelBg);
      labelBg.setAttribute('stroke', config.labelBorderColor);
      labelBg.setAttribute('stroke-width', config.labelBorderWidth);
      labelBg.setAttribute('rx', config.labelBorderRadius);
      labelBg.setAttribute('opacity', config.opacity / 100);
      
      connection.appendChild(labelBg);
      
      // Create text
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', midX);
      text.setAttribute('y', midY);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('dominant-baseline', 'middle');
      text.setAttribute('fill', config.labelTextColor);
      text.setAttribute('font-size', '10');
      text.setAttribute('font-family', 'Inter, sans-serif');
      text.setAttribute('opacity', config.opacity / 100);
      text.textContent = config.label;
      
      connection.appendChild(text);
    }
  }
  
  function createPreviewArrowHead(x, y, angle) {
    const arrowLength = 8;
    const arrowAngle = Math.PI / 6;
    
    const x1 = x - arrowLength * Math.cos(angle - arrowAngle);
    const y1 = y - arrowLength * Math.sin(angle - arrowAngle);
    const x2 = x - arrowLength * Math.cos(angle + arrowAngle);
    const y2 = y - arrowLength * Math.sin(angle + arrowAngle);
    
    const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    arrowHead.setAttribute('d', `M ${x1} ${y1} L ${x} ${y} L ${x2} ${y2}`);
    arrowHead.setAttribute('stroke', config.color);
    arrowHead.setAttribute('stroke-width', config.strokeWidth);
    arrowHead.setAttribute('fill', 'none');
    arrowHead.setAttribute('opacity', config.opacity / 100);
    
    return arrowHead;
  }
  
  // Tab functionality
  function initializeTabs() {
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs and content
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding content
        tab.classList.add('active');
        const tabId = tab.dataset.tab + '-tab';
        document.getElementById(tabId).classList.add('active');
      });
    });
  }

  // Initialize UI
  function initializeUI() {
    // Arrow color selection (only for main arrow colors, not label colors)
    document.querySelectorAll('[data-color]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-color]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.color = option.dataset.color;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Stroke width
    document.querySelectorAll('[data-width]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-width]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.strokeWidth = parseInt(option.dataset.width);
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Stroke style
    document.querySelectorAll('[data-style]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-style]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.strokeStyle = option.dataset.style;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Sloppiness
    document.querySelectorAll('[data-sloppiness]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-sloppiness]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.sloppiness = option.dataset.sloppiness;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Arrow type
    document.querySelectorAll('[data-arrow-type]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-arrow-type]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.arrowType = option.dataset.arrowType;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Arrowheads
    document.querySelectorAll('[data-arrowheads]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-arrowheads]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.arrowheads = option.dataset.arrowheads;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Start position
    document.querySelectorAll('[data-start-position]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-start-position]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.startPosition = option.dataset.startPosition;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // End position
    document.querySelectorAll('[data-end-position]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-end-position]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.endPosition = option.dataset.endPosition;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });
    
    // Opacity slider
    const opacitySlider = document.getElementById('opacity');
    const opacityValue = document.getElementById('opacityValue');
    
    opacitySlider.addEventListener('input', () => {
      config.opacity = parseInt(opacitySlider.value);
      opacityValue.textContent = opacitySlider.value;
      saveConfig();
      updatePreview();
      if (isEditingConnection) {
        updateConnection();
      } else {
        checkAutoCreate();
      }
    });
    
    // Connection offset slider
    const connectionOffsetSlider = document.getElementById('connectionOffset');
    const connectionOffsetValue = document.getElementById('connectionOffsetValue');
    
    connectionOffsetSlider.addEventListener('input', () => {
      config.connectionOffset = parseInt(connectionOffsetSlider.value);
      connectionOffsetValue.textContent = connectionOffsetSlider.value;
      saveConfig();
      updatePreview();
      if (isEditingConnection) {
        updateConnection();
      } else {
        checkAutoCreate();
      }
    });
    
    // Avoid overlap checkbox
    const avoidOverlapCheckbox = document.getElementById('avoidOverlap');
    avoidOverlapCheckbox.addEventListener('change', () => {
      config.avoidOverlap = avoidOverlapCheckbox.checked;
      saveConfig();
      updatePreview();
      if (isEditingConnection) {
        updateConnection();
      } else {
        checkAutoCreate();
      }
    });
    
    // Label input (now in preview area) with debouncing
    const labelInput = document.getElementById('labelPreview');
    let labelDebounceTimer = null;
    
    labelInput.addEventListener('input', () => {
      config.label = labelInput.value;
      
      // Update preview immediately for responsive UI
      updatePreview();
      
      // Clear existing timer
      if (labelDebounceTimer) {
        clearTimeout(labelDebounceTimer);
      }
      
      // Debounce the actual connection update and save
      labelDebounceTimer = setTimeout(() => {
        saveConfig();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      }, 300); // 300ms delay
    });
    
    // Label text color
    document.querySelectorAll('[data-label-text-color]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-label-text-color]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.labelTextColor = option.dataset.labelTextColor;
        debounceLabelUpdate();
      });
    });
    
    // Label background color
    document.querySelectorAll('[data-label-bg]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-label-bg]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.labelBg = option.dataset.labelBg;
        debounceLabelUpdate();
      });
    });
    
    // Label border color
    document.querySelectorAll('[data-label-border]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-label-border]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.labelBorderColor = option.dataset.labelBorder;
        debounceLabelUpdate();
      });
    });
    
    // Label border width
    document.querySelectorAll('[data-label-border-width]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-label-border-width]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.labelBorderWidth = parseInt(option.dataset.labelBorderWidth);
        debounceLabelUpdate();
      });
    });
    
    // Label border radius slider
    const labelBorderRadiusSlider = document.getElementById('labelBorderRadius');
    const labelBorderRadiusValue = document.getElementById('labelBorderRadiusValue');
    
    labelBorderRadiusSlider.addEventListener('input', () => {
      config.labelBorderRadius = parseInt(labelBorderRadiusSlider.value);
      labelBorderRadiusValue.textContent = labelBorderRadiusSlider.value;
      debounceLabelUpdate();
    });
    
    // Label padding slider
    const labelPaddingSlider = document.getElementById('labelPadding');
    const labelPaddingValue = document.getElementById('labelPaddingValue');
    
    labelPaddingSlider.addEventListener('input', () => {
      config.labelPadding = parseInt(labelPaddingSlider.value);
      labelPaddingValue.textContent = labelPaddingSlider.value;
      debounceLabelUpdate();
    });

    // Label position
    document.querySelectorAll('[data-label-position]').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('[data-label-position]').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        config.labelPosition = option.dataset.labelPosition;
        saveConfig();
        updatePreview();
        if (isEditingConnection) {
          updateConnection();
        } else {
          checkAutoCreate();
        }
      });
    });

    // Label offset slider
    const labelOffsetSlider = document.getElementById('labelOffset');
    const labelOffsetValue = document.getElementById('labelOffsetValue');
    
    labelOffsetSlider.addEventListener('input', () => {
      config.labelOffset = parseInt(labelOffsetSlider.value);
      labelOffsetValue.textContent = labelOffsetSlider.value;
      saveConfig();
      updatePreview();
      if (isEditingConnection) {
        updateConnection();
      } else {
        checkAutoCreate();
      }
    });

    // Auto-create checkbox
    const autoCreateCheckbox = document.getElementById('autoCreate');
    autoCreateCheckbox.addEventListener('change', () => {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'toggle-auto-create', 
          enabled: autoCreateCheckbox.checked 
        } 
      }, '*');
    });
    
    // Auto-update checkbox
    const autoUpdateCheckbox = document.getElementById('autoUpdate');
    autoUpdateCheckbox.addEventListener('change', () => {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'toggle-auto-update', 
          enabled: autoUpdateCheckbox.checked 
        } 
      }, '*');
    });
  }
  
  function updateConfigFromUI(newConfig) {
    // Update main arrow color selection
    document.querySelectorAll('[data-color]').forEach(option => {
      option.classList.toggle('selected', option.dataset.color === newConfig.color);
    });
    
    // Update stroke width
    document.querySelectorAll('[data-width]').forEach(option => {
      option.classList.toggle('selected', parseInt(option.dataset.width) === newConfig.strokeWidth);
    });
    
    // Update stroke style
    document.querySelectorAll('[data-style]').forEach(option => {
      option.classList.toggle('selected', option.dataset.style === newConfig.strokeStyle);
    });
    
    // Update sloppiness
    document.querySelectorAll('[data-sloppiness]').forEach(option => {
      option.classList.toggle('selected', option.dataset.sloppiness === newConfig.sloppiness);
    });
    
    // Update arrow type
    document.querySelectorAll('[data-arrow-type]').forEach(option => {
      option.classList.toggle('selected', option.dataset.arrowType === newConfig.arrowType);
    });
    
    // Update arrowheads
    document.querySelectorAll('[data-arrowheads]').forEach(option => {
      option.classList.toggle('selected', option.dataset.arrowheads === newConfig.arrowheads);
    });
    
    // Update start position
    document.querySelectorAll('[data-start-position]').forEach(option => {
      option.classList.toggle('selected', option.dataset.startPosition === newConfig.startPosition);
    });
    
    // Update end position
    document.querySelectorAll('[data-end-position]').forEach(option => {
      option.classList.toggle('selected', option.dataset.endPosition === newConfig.endPosition);
    });
    
    // Update connection offset
    document.getElementById('connectionOffset').value = newConfig.connectionOffset;
    document.getElementById('connectionOffsetValue').textContent = newConfig.connectionOffset;
    
    // Update avoid overlap
    document.getElementById('avoidOverlap').checked = newConfig.avoidOverlap;
    
    // Update opacity
    document.getElementById('opacity').value = newConfig.opacity;
    document.getElementById('opacityValue').textContent = newConfig.opacity;
    
    // Update label
    document.getElementById('labelPreview').value = newConfig.label || 'Label Text';
    
    // Update label text color
    document.querySelectorAll('[data-label-text-color]').forEach(option => {
      option.classList.toggle('selected', option.dataset.labelTextColor === newConfig.labelTextColor);
    });
    
    // Update label background color
    document.querySelectorAll('[data-label-bg]').forEach(option => {
      option.classList.toggle('selected', option.dataset.labelBg === newConfig.labelBg);
    });
    
    // Update label border color
    document.querySelectorAll('[data-label-border]').forEach(option => {
      option.classList.toggle('selected', option.dataset.labelBorder === newConfig.labelBorderColor);
    });
    
    // Update label border width
    document.querySelectorAll('[data-label-border-width]').forEach(option => {
      option.classList.toggle('selected', parseInt(option.dataset.labelBorderWidth) === newConfig.labelBorderWidth);
    });
    
    // Update label border radius
    document.getElementById('labelBorderRadius').value = newConfig.labelBorderRadius;
    document.getElementById('labelBorderRadiusValue').textContent = newConfig.labelBorderRadius;
    
    // Update label padding
    document.getElementById('labelPadding').value = newConfig.labelPadding;
    document.getElementById('labelPaddingValue').textContent = newConfig.labelPadding;
    
    // Update label position
    document.querySelectorAll('[data-label-position]').forEach(option => {
      option.classList.toggle('selected', option.dataset.labelPosition === newConfig.labelPosition);
    });
    
    // Update label offset
    document.getElementById('labelOffset').value = newConfig.labelOffset;
    document.getElementById('labelOffsetValue').textContent = newConfig.labelOffset;
    
    // Update config object
    config = { ...newConfig };
    updatePreview();
  }

  function checkAutoCreate() {
    const autoCreateEnabled = document.getElementById('autoCreate').checked;
    if (autoCreateEnabled && frameCount === 2 && !isEditingConnection) {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'auto-create-connection', 
          config: config 
        } 
      }, '*');
    }
  }
  
  function updateConnection() {
    if (selectedConnectionId) {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'update-connection', 
          connectionId: selectedConnectionId,
          config: config 
        } 
      }, '*');
    }
  }
  
  // Handle messages from plugin
  window.onmessage = (event) => {
    const msg = event.data.pluginMessage;
    
    if (msg.type === 'selection-changed') {
      frameCount = msg.frameCount;
      connectionCount = msg.connectionCount || 0;
      isEditingConnection = false;
      selectedConnectionId = null;
      updateUI();
      checkAutoCreate();
    }
    
    if (msg.type === 'connection-selected') {
      isEditingConnection = true;
      selectedConnectionId = msg.connectionId;
      frameCount = 0;
      connectionCount = 1;
      updateConfigFromUI(msg.config);
      showStatus(`Editing: ${msg.connectionName}`, 'editing');
      updateUI();
    }
    
    if (msg.type === 'get-config') {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'auto-create-connection', 
          config: config 
        } 
      }, '*');
    }
    
    if (msg.type === 'success') {
      showStatus(msg.message, 'success');
    }
    
    if (msg.type === 'error') {
      showStatus(msg.message, 'error');
    }
    
    if (msg.type === 'config-loaded') {
      // Update config with loaded data
      if (msg.config) {
        updateConfigFromUI(msg.config);
      }
    }
  };
  
  function updateUI() {
    const createButton = document.getElementById('create');
    const autoCreateEnabled = document.getElementById('autoCreate').checked;
    
    if (isEditingConnection) {
      createButton.textContent = 'Update Connection';
      createButton.disabled = false;
      return;
    }
    
    createButton.textContent = 'Create Connection';
    
    if (frameCount === 0) {
      if (connectionCount === 1) {
        // Don't override the editing status message
        return;
      }
      showStatus('Select 2 frames with Shift+Click to create a connection', 'info');
      createButton.disabled = true;
    } else if (frameCount === 1) {
      showStatus('Select 1 more frame to create a connection', 'info');
      createButton.disabled = true;
    } else if (frameCount === 2) {
      if (autoCreateEnabled) {
        showStatus('Auto-creating connection...', 'success');
        createButton.disabled = true;
      } else {
        showStatus('Ready to create connection between 2 frames', 'success');
        createButton.disabled = false;
      }
    } else {
      showStatus(`Too many frames selected (${frameCount}). Please select exactly 2 frames.`, 'error');
      createButton.disabled = true;
    }
  }
  
  function showStatus(message, type) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = `status ${type}`;
  }
  
  document.getElementById('create').onclick = () => {
    if (isEditingConnection) {
      updateConnection();
    } else {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'create-connection', 
          config: config 
        } 
      }, '*');
    }
  };
  
  document.getElementById('cancel').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };
  
  // Initialize when page loads
  initializeTabs();
  initializeUI();
  
  // Request saved config from backend
  parent.postMessage({ 
    pluginMessage: { 
      type: 'load-config'
    } 
  }, '*');
  
  // Initial preview update
  updatePreview();
</script>
